1: Describe the actions taken by a kernel to context-switch between
processes.

In general, the operating system must save the state of the currently
running process and restore the state of the process scheduled to be run
next. Saving the state of a process typically includes the values of all the
CPU registers in addition to memory allocation. Context switches must
also perform many architecture-specific operations, including flushing
data and instruction caches.

2: Answers will vary wildly.  Here is an example tree:

PID: 1 Name:/init
	PID: 556 Name:/sbin/ueventd
	PID: 807 Name:/system/bin/logd
	PID: 808 Name:/system/bin/debuggerd
		PID: 814 Name:debuggerd:signaller
	PID: 809 Name:/system/bin/debuggerd64
		PID: 813 Name:debuggerd64:signaller
	PID: 810 Name:/system/bin/vold
		PID: 1174 Name:/system/bin/sdcard
	PID: 837 Name:/sbin/healthd
	PID: 839 Name:/system/bin/lmkd
	PID: 840 Name:/system/bin/servicemanager
	PID: 841 Name:/system/bin/surfaceflinger
	PID: 844 Name:/system/bin/sh
	PID: 845 Name:/sbin/adbd
		PID: 1820 Name:ps
	PID: 846 Name:zygote64
		PID: 982 Name:system_server
		PID: 1169 Name:com.android.inputmethod.latin
		PID: 1175 Name:com.android.systemui
		PID: 1356 Name:com.android.phone
		PID: 1361 Name:com.android.settings
		PID: 1446 Name:com.android.deskclock
		PID: 1480 Name:android.ext.services
		PID: 1502 Name:android.process.acore
		PID: 1527 Name:com.android.keychain
		PID: 1541 Name:com.android.launcher3
		PID: 1570 Name:com.android.printspooler
		PID: 1607 Name:android.process.media
		PID: 1653 Name:com.android.quicksearchbox
		PID: 1677 Name:com.android.dialer
		PID: 1696 Name:com.android.calendar
		PID: 1717 Name:com.android.email
		PID: 1733 Name:com.android.providers.calendar
		PID: 1756 Name:com.android.managedprovisioning
		PID: 1771 Name:com.android.messaging
	PID: 847 Name:zygote
	PID: 848 Name:/system/bin/audioserver
	PID: 849 Name:/system/bin/cameraserver
	PID: 850 Name:/system/bin/drmserver
	PID: 851 Name:/system/bin/installd
	PID: 852 Name:/system/bin/keystore
	PID: 853 Name:media.codec
	PID: 854 Name:/system/bin/mediadrmserver
	PID: 855 Name:media.extractor
	PID: 856 Name:/system/bin/mediaserver
	PID: 857 Name:/system/bin/netd
	PID: 859 Name:/system/bin/rild
	PID: 860 Name:/system/bin/fingerprintd
	PID: 861 Name:/system/bin/gatekeeperd
	PID: 862 Name:/system/xbin/perfprofd
PID: 2 Name:kthreadd
	PID: 3 Name:ksoftirqd/0
	PID: 5 Name:kworker/0:0H
	PID: 6 Name:kworker/u2:0
	PID: 7 Name:migration/0
	PID: 8 Name:rcu_preempt
	PID: 9 Name:rcu_bh
	PID: 10 Name:rcu_sched
	PID: 11 Name:khelper
	PID: 12 Name:kworker/u2:1
	PID: 202 Name:writeback
	PID: 204 Name:bioset
	PID: 206 Name:kblockd
	PID: 301 Name:rpciod
	PID: 310 Name:kswapd0
	PID: 365 Name:fsnotify_mark
	PID: 381 Name:nfsiod
	PID: 393 Name:crypto
	PID: 518 Name:kpsmoused
	PID: 523 Name:kworker/0:2
	PID: 537 Name:binder
	PID: 555 Name:deferwq
	PID: 795 Name:kworker/0:1H
	PID: 796 Name:jbd2/vda-8
	PID: 798 Name:ext4-rsv-conver
	PID: 800 Name:jbd2/vdb-8
	PID: 801 Name:ext4-rsv-conver
	PID: 805 Name:jbd2/vdc-8
	PID: 806 Name:ext4-rsv-conver
	PID: 818 Name:kauditd
	PID: 1811 Name:kworker/0:0

3: On all current computers, at least part of the interrupt handlers are
written in assembly language. Why?

This is because all high level languages have certain immutable properties
that need to be disregarded for part of the interrupt handler code.  For example,
all high level languages have calling conventions that indicate what registers
to save, and where the arguments for the current function are.  However,
typically an interrupt handler code begins by a naked jmp to somewhere in memory
with no guarantees of register states.  A high level language such as C
cannot express how to go from this unreliable state to a reliable state where
the stack pointer is correct, and the arguments are all in the correct registers.
This must be done in assembly.  Furthermore, returning from an interrupt handler
can also have the same issues, for example x86 assembly requires the usage of an 
"iret" instruction which cannot be codegenerated by a compiler.

4:
See Q4_Diagram.pdf

5: The fork() entry point in the kernel is actually SYSCALL_DEFINE5(clone,...)
in fork.c.  The fork() code in libc ends up calling sys_clone with the SIGCHLD
flag which makes it equivalent to fork().  
Sys_clone calls into do_fork() with these flags informing the function that a
userspace process should be cloned.
This calls into _do_fork with the same parameters. The underscore prepending
identifies it as an internal function that code outside of fork.c should
not call directly.
The _do_fork mainly does two overall things: it copies the process using 
copy_process function, and makes the process runnable.
The copy_process is the bread and butter of the fork procedure.  It has many
specializations depending on whether a thread is being forked, or a process,
or some other edge case.  However, when a process is being forked copy_process:
p=dup_task_struct(current): Duplicate the currently running processes task_struct
                            Populate the task_struct->child and task_struct->sibling list
		            Adds struct to RCU data structure task_list (list of running tasks
			    on the system)
copy_semundo(p): Copies the named semaphore information so they can be released on process exit
copy_files(p): Copies file descriptors.
copy_fs(p): Copies file system information.
copy_sighand(p): Copies signal handlers
copy_signals(p): Copies pending signals
copy_mm(p): Copies the memory space
copy_io(p): Copies the IO context
copy_thread(p): Copies the thread as an execution entity
Although there is more code for handling edge cases in copy_process, this is
all the code relevant to what it means to fork(duplicate) a process.
Prior to returning _do_fork also takes a reference to the task_struct p
with get_task_struct(p)  This is cleaned up during process
exit to let the kernel know that the process is no longer considered
a process by the kernel scheduler subsystem.

6: There are many ways for a task to exit.  It could call the exit() function
or it could receive a signal which cannot be handled which causes to it
to terminate, or it could receive a SIGKILL (-9).  All these paths eventually
call do_exit with an exit code in kernel/exit.c.  do_exit is the counterpart
to fork, and does much of the cleanup of all the things that are allocated in
fork().

The do_exit() code also contains code for a thread exiting, so we will
focus on process exit code.  First we have to start closing all the things
that make process a process: memory, files, shared values, etc:
exit_mm(tsk): Closes the memory space.
exit_sem(tsk): Closes the named semaphores
exit_files(tsk): Closes references to open files
exit_fs(tsk): Closes the view to the filesystem
exit_thread(tsk): Closes userspace thread context
disassociate_ctty(1): Disconnect from Standard In/Standard Out/Standard Err
mpol_put(tsk->mempolicy): Closes memory policy (NUMA Aware memory allocation)
exit_notify(tsk): Notifies the process' parent that this process has exited
tsk->state = TASK_DEAD: Makes process state TASK_DEAD so it will not be run
sched(): Makes a call that will never return to the scheduler

Note we have not yet released the reference count that we allocated
in get_task_struct.  This is because this process must exist as a
Zombie until it's waited on by its parent.

Once its parent calls wait on the child we call into wait_task_zombie
which does cleanup and moves the process into EXIT_DEAD, which then
calls release_task.  release_task starts the work that will
lead to the put_task_struct which decrements the refcount.  However
note that the refcount may not be 0 because other kernel subsystems,
such as ipc_rec, may have a reference to this task.

Close inspection of put_task_struct shows eventually when the reference
count hits 0, the task_struct's kernel memory is actually freed.

7:Provide two programming examples in which multithreading does not
provide better performance than a single-threaded solution.

Answers will vary, here are two example answers
a. Any kind of sequential program is not a good candidate to be
threaded. An example of this is a program that calculates an
individual tax return.
b. Another example is a “shell” program such as the C-shell or Korn
shell. Such a program must closely monitor its own working space
such as open files, environment variables, and current working
directory.

8: Can a multithreaded solution using multiple user-level threads achieve
better performance on a multiprocessor system than on a single-
processor system? Explain.

A multithreaded system comprising of multiple user-level threads
cannot make use of the different processors in a multiprocessor system
simultaneously. The operating system sees only a single process and will
not schedule the different threads of the process on separate processors.
Consequently, there is no performance benefit associated with executing
multiple user-level threads on a multiprocessor system.
