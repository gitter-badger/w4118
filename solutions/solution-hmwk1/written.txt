Homework 1 Solutions ----------------------

(4 points)
1.4 Keeping in mind the various definitions of an operating system, consider
whether the operating system should include applications such as web browsers.

	Viewpoint #1: Applications are included in the OS
	------------------------------------------------------------
	The applications ship with the OS and allow users to interact with the
	hardware. The vendor ships these applications because from the users'
	perspective, the computer would be useless without them.

	Viewpoint #2: Applications are not included in the OS
	------------------------------------------------------------
	If we view the OS as the kernel, then it does not include applications.
	In this definition, the job of the OS is to provide a software interface
	between hardware and the applications that run on the machine.

==========

(4 points)
1.14 Under what circumstances would a user be better off using a time-
sharing system rather than a PC or a single-user workstation?

	When there are few other users, the task is large, and the hardware is fast,
	time-sharing makes sense. The full power of the system can be brought
	to bear on the user’s problem. The problem can be solved faster than on
	a personal computer. Another case occurs when lots of other users need
	resources at the same time.

	A personal computer is best when the job is small enough to be
	executed reasonably on it and when performance is sufficient to execute
	the program to the user’s satisfaction.

==========

(4 points)
1.19 What is the purpose of interrupts? How does an interrupt differ from a
trap? Can traps be generated intentionally by a user program? If so, for what
purpose?

	The purpose of an interrupt is for hardware to indicate to the kernel
	that an important event occurred so that the kernel can "handle" it.
	Kernels generally defined a fixed location, such as a table called the
	"interrupt vector", containing all the possible interrupt handlers. When
	these handlers finish, control is returned to the interrupted program.

	A trap, also known as an exception, is only generated by software, but
	is otherwise conceptually the same as an interrupt. Generally, a
	trap/exception is caused by an error of some sort, such as a divide by 0
	or invalid memory access, and a special handler is invoked.

	Yes, traps can be generated intentionally by a user program, for example
	when a user program requests that an operating system service be
	performed. Traps can also occur on arithmetic errors, such as divide by
	zero. (p21)

==========

(4 pts)
1.27 Describe some of the challenges of designing operating systems for mobile
devices compared with designing operating systems for traditional PCs.

	- Supporting specialized hardware such as GPS chips, accelerometers,
	  gyroscopes.

	- The operating system must manage power consumption carefully.

	- Optimizing a system for lower hardware specifications (e.g. less RAM,
	  less storage, less CPU power).

	- Security for a device that can be easily carried off (relative to
	  traditional PCs).

==========

(4 pts)

2.9 List five services provided by the OS, and explain how each creates
convenience for the user. In which cases would it be impossible for user-level
programs to provide these services?

	- Program execution: the OS is responsible for loading programs into
	  memory. For example, most flavors of Linux store executables as
	  ELF files (Executable and Linkable Format). The kernel includes a
	  loader whose job it is to load ELF files into memory. This allows
	  users to write programs that can be stored persistently and executed
	  at any time.

	  Technically, a user-space program can load binaries into memory and
	  execute them. Indeed, there are user-space Linux lodaders for machp-o
	  binaries (the OS X executable format). However, note that a user-space
	  loader would itself need to be loaded into memory by the kernel.

	- IO Operations: the primary job of an OS is to provide an interface to
	  the computer's hardware. Userspace programs generally cannot interact
	  with hardware directly. The OS provides hardware drivers for this
	  purpose.

	- File System Manipulation: OSes provided an interface to write/read
	  files to/from disks. The kernel interfaces with storage devices such
	  as disks, ssds and CD drives using the block IO layer. On top of the
	  block IO layer sit various filesystems - for example, ext4, FAT, and
	  many others. The file system controls the logical layout of
	  data on storage devices.

	  Userspace file systems do exist, but they're backed by kernel modules
	  with which they communicate. See FUSE as an example.

	- Interprocess Communication (IPC): OSes generally expose some
	  message-passing or signaling interface that allows processes to
	  communicate with one another. Linux IPC includes pipes, sockets,
	  shared memory, signals and named semaphores among other mechanisms.

	- User interface: OSes provide an interface for users to interact with
	  the computer. This can be as simple as a text-mode console, and as
	  complicated as a graphical desktop environment. Linux uses the X
	  window system as a framework to render graphics on screens. Desktop
	  environments such as GNOME, Unity and xfce are built on top of the X
	  windows system.

	  Although desktop environments usually ship with OSes, they're
	  technically userspace programs. Thus, the question of whether or not
	  the OS includes the desktop environment is up to debate.


==========

(4 pts)

2.18 What are the two models of interprocess communication? What are the
strengths and weaknesses of the two approaches?

	The two models of interprocess communication are message-passing model
	and the shared-memory model.

	Message passing is useful for exchanging smaller amounts of data,
	because no conflicts need be avoided. It is also easier to implement
	than is shared memory for intercomputer communication.

	Shared memory allows maximum speed and convenience of communication,
	since it can be done at memory transfer speeds when it takes place
	within a computer. However, this method compromises on protection and
	synchronization between the processes sharing memory.


==========

(4 pts)

2.21 What is the main advantage of the microkernel approach to system design?
How do user programs and system services interact in a microkernel
architecture? What are the disadvantages of using the microkernel approach?

	Benefits typically include the following:

		(a) adding a new service does not require modifying the kernel
		(b) it is more secure as more operations are done in user mode
		    than in kernel mode
		(c) a simpler kernel design and functionality typically results
		    in a more reliable operating system.

	User programs and system services interact in a microkernel architecture
	by using interprocess communication mechanisms such as messaging. These
	messages are conveyed by the operating system.  The primary
	disadvantages of the microkernel architecture are the overheads
	associated with interprocess communication and the frequent use of the
	operating system’s messaging functions in order to enable the user
	process and the system service to interact with each other.

==========

(4 pts)

2.24 Explain why Java programs running on Android systems do not use the
standard Java API and virtual machine.

	Short answer: Java API redesigned for mobile computing so that it can be
	preloaded and stored in memory at all times. Also, Android has Dalvik
	virtual machine, and which compiles Java bytecode further before running
	it.

	Java programs on Android execute in a special runtime environment, the
	Android runtime, which contains a set of core libraries and the Dalvik
	virtual machine.

	The core libraries are essentially preloaded Java libraries modified for
	Android use. Thus, Java on Android does not use the Java API, but a
	specialized Android Java API.

	The Dalvik virtual machine is where the Java code runs. However, the
	Dalvik virtual machine does not directly run compiled Java bytecode.
	Instead, Java bytecode is translated to a binary format understood by
	the Dalvik VM, and is then executed. The Dalvik VM itself is designed to
	optimize execution for low-memory and low-cpu conditions.

	(see p84-86)
